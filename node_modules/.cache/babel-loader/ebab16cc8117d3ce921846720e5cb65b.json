{"ast":null,"code":"var _jsxFileName = \"/Users/amloewi/Code/ladder-of-babel/src/App.js\";\nimport React, { useState } from 'react';\nimport './App.css';\nimport { cedict } from \"./medium.js\"; // do one for medium w ... 50k\n\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\n\nimport { Container, Row, Col, Navbar, Button, Nav, Modal } from 'react-bootstrap';\n\nclass Translation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.text = React.createRef();\n    this.state = {\n      translation: [],\n      text: \"在此贴你自己的内容!\"\n    }; // Would prefer the less insane syntax for this\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  }\n\n  handleInputChange(event) {\n    this.setState({\n      text: event.target.value,\n      translation: this.translate(event.target.value)\n    });\n  }\n\n  translate(text) {\n    // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n    // const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n    const translation = [];\n    let remaining_characters = text;\n\n    while (remaining_characters.length > 0) {\n      let word_boundary = 1;\n      let best_candidate = null;\n\n      while (remaining_characters.length > 0) {\n        const candidate = remaining_characters.slice(0, word_boundary);\n\n        if (candidate in cedict && word_boundary <= remaining_characters.length) {\n          best_candidate = candidate;\n          word_boundary += 1;\n        } else {\n          // candidate is NOT in the dictionary\n          if (best_candidate != null) {\n            // at least the first character was recognized\n            const line = String(cedict[best_candidate]);\n            const pinyin = line.split(/](.+)/)[0] + \"]\";\n            const definition = line.split(/](.+)/)[1].slice(1); // I only want to split on the FIRST; \n\n            translation.push({\n              \"token\": best_candidate,\n              \"pinyin\": pinyin,\n              \"definition\": definition\n            });\n          } else {\n            const token = remaining_characters[0]; // const definition = token in punctuation ? \"\" : \"??\"\n\n            translation.push({\n              \"token\": token,\n              \"pinyin\": \"\",\n              \"definition\": \"\"\n            });\n          }\n\n          if (word_boundary > 1) {\n            remaining_characters = remaining_characters.slice(word_boundary - 1);\n          } else {\n            remaining_characters = remaining_characters.slice(word_boundary);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return translation;\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      type: \"text\",\n      onChange: this.handleInputChange,\n      value: this.state.text,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"p\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 72,\n        columnNumber: 9\n      }\n    }), this.state.translation.map((word, ix) => /*#__PURE__*/React.createElement(Row, {\n      key: ix,\n      style: {\n        textAlign: \"left\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 74,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75,\n        columnNumber: 13\n      }\n    }, word[\"token\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 76,\n        columnNumber: 13\n      }\n    }, word[\"pinyin\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 8,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77,\n        columnNumber: 13\n      }\n    }, word[\"definition\"]))), this.state.translation.map((word, ix) => /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 81,\n        columnNumber: 11\n      }\n    }, \"\\\"token\\\":\", word[\"token\"], \", \\\"pinyin\\\":\", word[\"pinyin\"], \", \\\"definition\\\":\", word[\"definition\"])));\n  }\n\n}\n\nfunction About() {\n  const [show, setShow] = useState(false);\n\n  const handleClose = () => setShow(false);\n\n  const handleShow = () => setShow(true);\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, {\n    variant: \"primary\",\n    onClick: handleShow,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 7\n    }\n  }, \"About\"), /*#__PURE__*/React.createElement(Modal, {\n    show: show,\n    onHide: handleClose,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(Modal.Header, {\n    closeButton: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(Modal.Title, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 11\n    }\n  }, \"About Ladder of Babel\")), /*#__PURE__*/React.createElement(Modal.Body, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 106,\n      columnNumber: 9\n    }\n  }, \"Ladder of Babel is a tool for beginner and intermediate students of Chinese that makes any (simplified) text accessible by solving a serious problem with most current tools.\", /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 51\n    }\n  }), \"Tools such as the Google Translate browser plugin, or the similar Mate Translate, are perfect for translating a single word at a time. They are clearly an enormous improvement over having to search through a paper dictionary. However, they are still best for people who only need to pick out words one by one, whereas most Chinese language learners both need to translate \", /*#__PURE__*/React.createElement(\"b\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 65\n    }\n  }, \"most\"), \" of the words - and, probably don't even know which characters\", /*#__PURE__*/React.createElement(\"b\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 12\n    }\n  }, \" form\"), \" a single word.\", /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 39\n    }\n  }), \"Ladder of Babel solves both of these problems by pre-identifying which characters form words, and giving definitions for everything, at once - making the reading experience as seamless and fluent as possible even for early stage students, and opening up the entire world of online Chinese text for easy access, and also productive study.\"), /*#__PURE__*/React.createElement(Modal.Footer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 118,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(Button, {\n    variant: \"primary\",\n    onClick: handleClose,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 11\n    }\n  }, \"Close\"))));\n}\n\nfunction App() {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Navbar, {\n    bg: \"light\",\n    expand: \"lg\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 131,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(Navbar.Brand, {\n    href: \"#home\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 9\n    }\n  }, \"Ladder of Babel\"), /*#__PURE__*/React.createElement(Nav, {\n    className: \"mr-auto\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 9\n    }\n  }), \" \", /*#__PURE__*/React.createElement(About, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(Nav.Link, {\n    href: \"http://dovecoteinstitute.org\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 9\n    }\n  }, \"Dovecote Institute\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(Translation, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"hr\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"footer\", {\n    class: \"container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 141,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 9\n    }\n  }, \"\\xA9 Dovecote Institute 2020\")));\n}\n\nexport default App; // “我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。","map":{"version":3,"sources":["/Users/amloewi/Code/ladder-of-babel/src/App.js"],"names":["React","useState","cedict","Container","Row","Col","Navbar","Button","Nav","Modal","Translation","Component","constructor","props","text","createRef","state","translation","handleInputChange","bind","event","setState","target","value","translate","remaining_characters","length","word_boundary","best_candidate","candidate","slice","line","String","pinyin","split","definition","push","token","render","map","word","ix","textAlign","About","show","setShow","handleClose","handleShow","App"],"mappings":"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","sourcesContent":["import React, { useState } from 'react';\nimport './App.css';\nimport { cedict } from \"./medium.js\"; // do one for medium w ... 50k\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\nimport { Container, Row, Col, Navbar, Button, Nav, Modal } from 'react-bootstrap';\n\n\nclass Translation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.text = React.createRef();\n    this.state = {\n      translation: [],\n      text: \"在此贴你自己的内容!\"\n    };\n    // Would prefer the less insane syntax for this\n    this.handleInputChange = this.handleInputChange.bind(this)\n  }\n\n  handleInputChange(event) {\n    this.setState({\n      text: event.target.value,\n      translation: this.translate(event.target.value)        \n    })\n  }\n\n  translate(text) { \n    // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n    // const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n\n    const translation = []\n    let remaining_characters = text\n    while (remaining_characters.length > 0) {\n        let word_boundary = 1\n        let best_candidate = null\n        while (remaining_characters.length > 0) {\n            const candidate = remaining_characters.slice(0, word_boundary)\n            if ((candidate in cedict) && (word_boundary <= remaining_characters.length)) {\n                best_candidate = candidate\n                word_boundary += 1\n            } else {  // candidate is NOT in the dictionary\n                if (best_candidate != null) {  // at least the first character was recognized\n                  const line = String(cedict[best_candidate])\n                  const pinyin = (line.split(/](.+)/)[0]) + \"]\"\n                  const definition = (line.split(/](.+)/)[1]).slice(1) // I only want to split on the FIRST; \n                  translation.push({\"token\": best_candidate, \"pinyin\": pinyin, \"definition\": definition})\n                } else {\n                    const token = remaining_characters[0]\n                    // const definition = token in punctuation ? \"\" : \"??\"\n                    translation.push({\"token\": token, \"pinyin\": \"\", \"definition\": \"\"})\n                }\n                if (word_boundary > 1) {\n                    remaining_characters = remaining_characters.slice(word_boundary-1)\n                } else {\n                    remaining_characters = remaining_characters.slice(word_boundary)\n                }\n                break\n            }\n        }\n    }\n    return(translation)\n  }\n\n  render() {\n    return(\n      <Container>\n        <input\n            type=\"text\"\n            onChange={ this.handleInputChange }\n            value={ this.state.text }\n        />\n        <p></p>\n        {this.state.translation.map((word, ix) =>\n          <Row key={ix} style={{textAlign: \"left\"}}>\n            <Col md={2}>{word[\"token\"]}</Col> \n            <Col md={2}>{word[\"pinyin\"]}</Col>\n            <Col md={8}>{word[\"definition\"]}</Col>\n          </Row>\n        )}\n        { this.state.translation.map((word, ix) =>\n          <div>\n          \"token\":{word[\"token\"]}, \"pinyin\":{word[\"pinyin\"]}, \"definition\":{word[\"definition\"]}\n          </div>\n        )}\n      </Container>\n    ) \n  }\n}\n\nfunction About() {\n  const [show, setShow] = useState(false);\n\n  const handleClose = () => setShow(false);\n  const handleShow = () => setShow(true);\n\n  return (\n    <>\n      <Button variant=\"primary\" onClick={handleShow}>\n        About\n      </Button>\n\n      <Modal show={show} onHide={handleClose}>\n        <Modal.Header closeButton>\n          <Modal.Title>About Ladder of Babel</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          Ladder of Babel is a tool for beginner and intermediate students of Chinese that makes any (simplified) text accessible by solving a \n          serious problem with most current tools.<p></p>\n          Tools such as the Google Translate browser plugin, or the similar Mate Translate, are perfect for translating a single word at a time. They are \n          clearly an enormous improvement over having to search through a paper dictionary. However, they are still best for people who only need to pick out\n          words one by one, whereas\n          most Chinese language learners both need to translate <b>most</b> of the words - and, probably don't even know which characters \n           <b> form</b> a single word.<p></p>\n           Ladder of Babel solves both of these problems by pre-identifying which characters form words, and giving definitions for everything, at once - \n           making the reading experience as seamless and fluent as possible even for early stage students, and opening up the entire world of online Chinese\n           text for easy access, and also productive study.\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"primary\" onClick={handleClose}>\n            Close\n          </Button>\n        </Modal.Footer>\n      </Modal>\n    </>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Navbar bg=\"light\" expand=\"lg\">\n        <Navbar.Brand href=\"#home\">Ladder of Babel</Navbar.Brand>\n        <Nav className=\"mr-auto\"></Nav> {/* Using this to push the rest to the right */}\n        <About />\n        <Nav.Link href=\"http://dovecoteinstitute.org\">Dovecote Institute</Nav.Link>\n      </Navbar>\n\n      <p></p>\n      <Translation />\n      <hr></hr>\n      <footer class=\"container\">\n        <p>&copy; Dovecote Institute 2020</p>\n      </footer>\n    </div>\n\n  );\n}\n\nexport default App;\n\n// “我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。"]},"metadata":{},"sourceType":"module"}