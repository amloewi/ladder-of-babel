{"ast":null,"code":"var _jsxFileName = \"/Users/amloewi/Code/lob/src/App.js\";\n// const {useState} = React;\n// function App () {\n//   function Child(props) {\n//     const {caption} = props;\n//     const {lines, setLines} = props.pstate;\n//     return <button onClick={() => {\n//       setLines([...lines, lines.length]);\n//     }}>\n//       {caption}\n//     </button>;\n//   }\n//   function Parent(props) {\n//     const [lines, setLines] = useState([0]);  \n//     return lines.map(m => <Child key={m} caption={`Click ${m}`} pstate={{lines, setLines}}/>);\n//   }\n//   return (\n//     <Parent />\n//   )\n// }\n// export default App;\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { cedict } from \"./small.js\";\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\n\nimport { Container, Row, Col } from 'react-bootstrap';\n\nclass Translator extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.translate = function (text) {\n      // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n      const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"];\n      const translation = [];\n      let remaining_characters = text; // props.text\n\n      while (remaining_characters.length > 0) {\n        let word_boundary = 1;\n        let best_candidate = null;\n\n        while (remaining_characters.length > 0) {\n          const candidate = remaining_characters.slice(0, word_boundary); // [:word_boundary] // XXX\n          // console.log(candidate)\n          // console.log(candidate in cedict) // fuck; different ... something. Fuck!\n\n          if (candidate in cedict && word_boundary <= remaining_characters.length) {\n            best_candidate = candidate;\n            word_boundary += 1;\n          } else {\n            // candidate is NOT in the dictionary\n            if (best_candidate != null) {\n              // at least the first character was recognized\n              const line = String(cedict[best_candidate]);\n              const pinyin = line.split(/](.+)/)[0] + \"]\";\n              const definition = line.split(/](.+)/)[1].slice(1); // I only want to split on the FIRST; \n\n              translation.push({\n                \"token\": best_candidate,\n                \"pinyin\": pinyin,\n                \"definition\": definition\n              });\n            } else {\n              const token = remaining_characters[0];\n              const definition = token in punctuation ? \"\" : \"??\"; // \"\\n\" if token in punctuation else \"??\\n\"  // \n\n              translation.push({\n                \"token\": token,\n                \"pinyin\": \"\",\n                \"definition\": \"\"\n              }); // definition} )\n            }\n\n            if (word_boundary > 1) {\n              remaining_characters = remaining_characters.slice(word_boundary - 1); // [word_boundary-1:]\n            } else {\n              remaining_characters = remaining_characters.slice(word_boundary); // [word_boundary:]\n            }\n\n            break;\n          }\n        }\n      }\n\n      return translation;\n    };\n\n    this.state = {\n      translation: []\n    }; // Would prefer the less insane syntax for this\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  } // The translation function\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 85,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      type: \"text\" // value={ this.state.text }\n      ,\n      onChange: this.handleInputChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 9\n      }\n    }), this.state.translation.map((word, ix) => /*#__PURE__*/React.createElement(Row, {\n      key: ix,\n      style: {\n        textAlign: \"left\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 92,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 93,\n        columnNumber: 13\n      }\n    }, word[\"token\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 94,\n        columnNumber: 13\n      }\n    }, word[\"pinyin\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 8,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 95,\n        columnNumber: 13\n      }\n    }, word[\"definition\"]))));\n  }\n\n}\n\nfunction App() {\n  // function Translation(props) { \n  //   // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n  //   const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n  //   const translation = []\n  //   let remaining_characters = props.text\n  //   while (remaining_characters.length > 0) {\n  //       let word_boundary = 1\n  //       let best_candidate = null\n  //       while (remaining_characters.length > 0) {\n  //           const candidate = remaining_characters.slice(0, word_boundary)  // [:word_boundary] // XXX\n  //           console.log(candidate)\n  //           console.log(candidate in cedict) // fuck; different ... something. Fuck!\n  //           if ((candidate in cedict) && (word_boundary <= remaining_characters.length)) {\n  //               best_candidate = candidate\n  //               word_boundary += 1\n  //           } else {  // candidate is NOT in the dictionary\n  //               if (best_candidate != null) {  // at least the first character was recognized\n  //                 const line = String(cedict[best_candidate])\n  //                 const pinyin = (line.split(/](.+)/)[0]) + \"]\"\n  //                 const definition = (line.split(/](.+)/)[1]).slice(1) // I only want to split on the FIRST; \n  //                 translation.push({\"token\": best_candidate, \"pinyin\": pinyin, \"definition\": definition})\n  //               } else {\n  //                   const token = remaining_characters[0]\n  //                   const definition = token in punctuation ? \"\" : \"??\"  // \"\\n\" if token in punctuation else \"??\\n\"  // \n  //                   translation.push({\"token\": token, \"pinyin\": \"\", \"definition\": \"\"}) // definition} )\n  //               }\n  //               if (word_boundary > 1) {\n  //                   remaining_characters = remaining_characters.slice(word_boundary-1)  // [word_boundary-1:]\n  //               } else {\n  //                   remaining_characters = remaining_characters.slice(word_boundary)  // [word_boundary:]\n  //               }\n  //               break\n  //           }\n  //       }\n  //   }\n  //   return(\n  //     <Container>\n  //       <input type=\"text\"></input>\n  //       {translation.map((word, ix) =>\n  //         <Row key={ix} style={{textAlign: \"left\"}}>\n  //           <Col md={2}>{word[\"token\"]}</Col> \n  //           <Col md={2}>{word[\"pinyin\"]}</Col>\n  //           <Col md={8}>{word[\"definition\"]}</Col>\n  //         </Row>\n  //       )}\n  //     </Container>\n  //   )\n  // }\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 155,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 7\n    }\n  }, \"Ladder of Babel\"), /*#__PURE__*/React.createElement(Translation, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default App; // \"“我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。\"","map":{"version":3,"sources":["/Users/amloewi/Code/lob/src/App.js"],"names":["React","useState","useEffect","cedict","Container","Row","Col","Translator","Component","constructor","props","translate","text","punctuation","translation","remaining_characters","length","word_boundary","best_candidate","candidate","slice","line","String","pinyin","split","definition","push","token","state","handleInputChange","bind","render","map","word","ix","textAlign","App"],"mappings":"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","sourcesContent":["// const {useState} = React;\n\n// function App () {\n//   function Child(props) {\n//     const {caption} = props;\n//     const {lines, setLines} = props.pstate;\n//     return <button onClick={() => {\n//       setLines([...lines, lines.length]);\n//     }}>\n//       {caption}\n//     </button>;\n//   }\n\n//   function Parent(props) {\n//     const [lines, setLines] = useState([0]);  \n//     return lines.map(m => <Child key={m} caption={`Click ${m}`} pstate={{lines, setLines}}/>);\n//   }\n//   return (\n//     <Parent />\n//   )\n// }\n\n// export default App;\n\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { cedict } from \"./small.js\";\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\nimport { Container, Row, Col } from 'react-bootstrap';\n\n\nclass Translator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      translation: []\n    };\n    // Would prefer the less insane syntax for this\n    this.handleInputChange = this.handleInputChange.bind(this)\n  }\n\n  // The translation function\n  translate = function (text) { \n    // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n    const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n\n    const translation = []\n    let remaining_characters = text // props.text\n    while (remaining_characters.length > 0) {\n        let word_boundary = 1\n        let best_candidate = null\n        while (remaining_characters.length > 0) {\n            const candidate = remaining_characters.slice(0, word_boundary)  // [:word_boundary] // XXX\n            // console.log(candidate)\n            // console.log(candidate in cedict) // fuck; different ... something. Fuck!\n            if ((candidate in cedict) && (word_boundary <= remaining_characters.length)) {\n                best_candidate = candidate\n                word_boundary += 1\n            } else {  // candidate is NOT in the dictionary\n                if (best_candidate != null) {  // at least the first character was recognized\n                  const line = String(cedict[best_candidate])\n                  const pinyin = (line.split(/](.+)/)[0]) + \"]\"\n                  const definition = (line.split(/](.+)/)[1]).slice(1) // I only want to split on the FIRST; \n                  translation.push({\"token\": best_candidate, \"pinyin\": pinyin, \"definition\": definition})\n                } else {\n                    const token = remaining_characters[0]\n                    const definition = token in punctuation ? \"\" : \"??\"  // \"\\n\" if token in punctuation else \"??\\n\"  // \n                    translation.push({\"token\": token, \"pinyin\": \"\", \"definition\": \"\"}) // definition} )\n                }\n                if (word_boundary > 1) {\n                    remaining_characters = remaining_characters.slice(word_boundary-1)  // [word_boundary-1:]\n                } else {\n                    remaining_characters = remaining_characters.slice(word_boundary)  // [word_boundary:]\n                }\n                break\n            }\n        }\n    }\n    return(translation)\n  }\n  \n\n  render() {\n    return(\n      <Container>\n        <input\n            type=\"text\"\n            // value={ this.state.text }\n            onChange={ this.handleInputChange }\n        />\n        {this.state.translation.map((word, ix) =>\n          <Row key={ix} style={{textAlign: \"left\"}}>\n            <Col md={2}>{word[\"token\"]}</Col> \n            <Col md={2}>{word[\"pinyin\"]}</Col>\n            <Col md={8}>{word[\"definition\"]}</Col>\n          </Row>\n        )}\n      </Container>\n    )  }\n}\n\nfunction App() {\n\n  // function Translation(props) { \n  //   // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n  //   const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n\n  //   const translation = []\n  //   let remaining_characters = props.text\n  //   while (remaining_characters.length > 0) {\n  //       let word_boundary = 1\n  //       let best_candidate = null\n  //       while (remaining_characters.length > 0) {\n  //           const candidate = remaining_characters.slice(0, word_boundary)  // [:word_boundary] // XXX\n  //           console.log(candidate)\n  //           console.log(candidate in cedict) // fuck; different ... something. Fuck!\n  //           if ((candidate in cedict) && (word_boundary <= remaining_characters.length)) {\n  //               best_candidate = candidate\n  //               word_boundary += 1\n  //           } else {  // candidate is NOT in the dictionary\n  //               if (best_candidate != null) {  // at least the first character was recognized\n  //                 const line = String(cedict[best_candidate])\n  //                 const pinyin = (line.split(/](.+)/)[0]) + \"]\"\n  //                 const definition = (line.split(/](.+)/)[1]).slice(1) // I only want to split on the FIRST; \n  //                 translation.push({\"token\": best_candidate, \"pinyin\": pinyin, \"definition\": definition})\n  //               } else {\n  //                   const token = remaining_characters[0]\n  //                   const definition = token in punctuation ? \"\" : \"??\"  // \"\\n\" if token in punctuation else \"??\\n\"  // \n  //                   translation.push({\"token\": token, \"pinyin\": \"\", \"definition\": \"\"}) // definition} )\n  //               }\n  //               if (word_boundary > 1) {\n  //                   remaining_characters = remaining_characters.slice(word_boundary-1)  // [word_boundary-1:]\n  //               } else {\n  //                   remaining_characters = remaining_characters.slice(word_boundary)  // [word_boundary:]\n  //               }\n  //               break\n  //           }\n  //       }\n  //   }\n  //   return(\n  //     <Container>\n  //       <input type=\"text\"></input>\n  //       {translation.map((word, ix) =>\n  //         <Row key={ix} style={{textAlign: \"left\"}}>\n  //           <Col md={2}>{word[\"token\"]}</Col> \n  //           <Col md={2}>{word[\"pinyin\"]}</Col>\n  //           <Col md={8}>{word[\"definition\"]}</Col>\n  //         </Row>\n  //       )}\n  //     </Container>\n  //   )\n  // }\n\n  return (\n    <div className=\"App\">\n      <h1>Ladder of Babel</h1>\n      <Translation />\n    </div>\n  );\n}\n\nexport default App;\n\n// \"“我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。\""]},"metadata":{},"sourceType":"module"}