{"ast":null,"code":"var _jsxFileName = \"/Users/amloewi/Code/lob/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { cedict } from \"./small.js\";\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\n\nimport { Container, Row, Col } from 'react-bootstrap';\n\nclass Translation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      translation: []\n    }; // Would prefer the less insane syntax for this\n\n    this.handleInputChange = this.handleInputChange.bind(this);\n  }\n\n  handleInputChange(event) {\n    this.setState({\n      translation: this.translate(event.target.value)\n    });\n  }\n\n  translate(text) {\n    // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n    const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"];\n    const translation = [];\n    let remaining_characters = text;\n\n    while (remaining_characters.length > 0) {\n      let word_boundary = 1;\n      let best_candidate = null;\n\n      while (remaining_characters.length > 0) {\n        const candidate = remaining_characters.slice(0, word_boundary);\n\n        if (candidate in cedict && word_boundary <= remaining_characters.length) {\n          best_candidate = candidate;\n          word_boundary += 1;\n        } else {\n          // candidate is NOT in the dictionary\n          if (best_candidate != null) {\n            // at least the first character was recognized\n            const line = String(cedict[best_candidate]);\n            const pinyin = line.split(/](.+)/)[0] + \"]\";\n            const definition = line.split(/](.+)/)[1].slice(1); // I only want to split on the FIRST; \n\n            translation.push({\n              \"token\": best_candidate,\n              \"pinyin\": pinyin,\n              \"definition\": definition\n            });\n          } else {\n            const token = remaining_characters[0];\n            const definition = token in punctuation ? \"\" : \"??\";\n            translation.push({\n              \"token\": token,\n              \"pinyin\": \"\",\n              \"definition\": \"\"\n            });\n          }\n\n          if (word_boundary > 1) {\n            remaining_characters = remaining_characters.slice(word_boundary - 1);\n          } else {\n            remaining_characters = remaining_characters.slice(word_boundary);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return translation;\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"input\", {\n      type: \"text\",\n      onChange: this.handleInputChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 64,\n        columnNumber: 9\n      }\n    }), this.state.translation.map((word, ix) => /*#__PURE__*/React.createElement(Row, {\n      key: ix,\n      style: {\n        textAlign: \"left\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 69,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 70,\n        columnNumber: 13\n      }\n    }, word[\"token\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 2,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71,\n        columnNumber: 13\n      }\n    }, word[\"pinyin\"]), /*#__PURE__*/React.createElement(Col, {\n      md: 8,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 72,\n        columnNumber: 13\n      }\n    }, word[\"definition\"]))));\n  }\n\n}\n\nfunction App() {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 7\n    }\n  }, \"Ladder of Babel\"), /*#__PURE__*/React.createElement(Translation, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default App; //         text=\"“我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。\"","map":{"version":3,"sources":["/Users/amloewi/Code/lob/src/App.js"],"names":["React","useState","useEffect","cedict","Container","Row","Col","Translation","Component","constructor","props","state","translation","handleInputChange","bind","event","setState","translate","target","value","text","punctuation","remaining_characters","length","word_boundary","best_candidate","candidate","slice","line","String","pinyin","split","definition","push","token","render","map","word","ix","textAlign","App"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport { cedict } from \"./small.js\";\nimport '../node_modules/bootstrap/dist/css/bootstrap.min.css'; // This was necessary; ugh\nimport { Container, Row, Col } from 'react-bootstrap';\n\n\nclass Translation extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      translation: []\n    };\n    // Would prefer the less insane syntax for this\n    this.handleInputChange = this.handleInputChange.bind(this)\n  }\n\n  handleInputChange(event) {\n    this.setState({\n        translation: this.translate(event.target.value)\n    })\n  }\n\n  translate(text) { \n    // This is super sloppy for all sorts of reasons; do need the chinese punctuation though\n    const punctuation = [\"，\", \"。\", \"「\", \"」\", \"、\", \"‧\", \".\", \";\", \" \", \"\\t\"]\n\n    const translation = []\n    let remaining_characters = text\n    while (remaining_characters.length > 0) {\n        let word_boundary = 1\n        let best_candidate = null\n        while (remaining_characters.length > 0) {\n            const candidate = remaining_characters.slice(0, word_boundary)\n            if ((candidate in cedict) && (word_boundary <= remaining_characters.length)) {\n                best_candidate = candidate\n                word_boundary += 1\n            } else {  // candidate is NOT in the dictionary\n                if (best_candidate != null) {  // at least the first character was recognized\n                  const line = String(cedict[best_candidate])\n                  const pinyin = (line.split(/](.+)/)[0]) + \"]\"\n                  const definition = (line.split(/](.+)/)[1]).slice(1) // I only want to split on the FIRST; \n                  translation.push({\"token\": best_candidate, \"pinyin\": pinyin, \"definition\": definition})\n                } else {\n                    const token = remaining_characters[0]\n                    const definition = token in punctuation ? \"\" : \"??\"\n                    translation.push({\"token\": token, \"pinyin\": \"\", \"definition\": \"\"})\n                }\n                if (word_boundary > 1) {\n                    remaining_characters = remaining_characters.slice(word_boundary-1)\n                } else {\n                    remaining_characters = remaining_characters.slice(word_boundary)\n                }\n                break\n            }\n        }\n    }\n    return(translation)\n  }\n\n  render() {\n    return(\n      <Container>\n        <input\n            type=\"text\"\n            onChange={ this.handleInputChange }\n        />\n        {this.state.translation.map((word, ix) =>\n          <Row key={ix} style={{textAlign: \"left\"}}>\n            <Col md={2}>{word[\"token\"]}</Col> \n            <Col md={2}>{word[\"pinyin\"]}</Col>\n            <Col md={8}>{word[\"definition\"]}</Col>\n          </Row>\n        )}\n      </Container>\n    ) \n  }\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h2>Ladder of Babel</h2>\n\n      <Translation />\n    </div>\n  );\n}\n\nexport default App;\n\n//         text=\"“我有两张自拍，一张很丑，另一张还是很丑”（“在我的后园，可以看见墙外有两株树，一株是枣树，还有一株也是枣树。”——迅哥原文）\n// 100年前的鲁迅万万没有预料到，自己在当下的符号是“中文互联网梗王”、“金句界顶流”。\n// 在各种社会热点的留言评论区，在各大平台的鸡汤文学里，鲁迅语录随处可见；无论搭不搭边，“鲁迅曾经说过”就在那里，从不缺席。\n// 北京鲁迅博物馆为此专门建了一个检索系统，在这里，所有“鲁迅说过的话”都可以被验证或者打脸，该系统还不止一次因为查询人数过多而崩溃。\n// 在互联网的迷幻国度里，人人以为自己熟读鲁迅。\n// 人人不知道的是，这个活在100年前的老男孩，早早已将我们读懂、看透。\""]},"metadata":{},"sourceType":"module"}